https://leetcode.com/problemset/algorithms/


16. 3sum-closest
"""
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

    For example, given array S = {-1 2 1 -4}, and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
"""


20. valid-parentheses
"""
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.
"""


27. remove-element
Given an array and a value, remove all instances of that value in place and return the new length.
Do not allocate extra space for another array, you must do this in place with constant memory.
The order of elements can be changed. It doesn't matter what you leave beyond the new length.
Example:
Given input array nums = [3,2,2,3], val = 3
Your function should return length = 2, with the first two elements of nums being 2.


42. trapping-rain-water
"""
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

For example, 
Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
"""


50. powx-n
Implement pow(x, n)
n maybe a negtive number


55. jump-game
"""
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

For example:
A = [2,3,1,1,4], return true.

A = [3,2,1,0,4], return false.
"""
Solution one uses recursive function, but will get stack overflow. And it can not handle an array even with only 23 integers.

Solution two transfers recursive function to a loop but with the same method. Then it can solve the 23 intergers array, but fail when the array has 20000+ integers (all are one).

Solution three changes the search direction from left2right to right2left, but makes little difference.
Solution one has O(n!) time complexity and Solution two & three have O(n^2) time efficiency, therefore I try Solution four which has O(n) time efficiency.

At the first beginning, Solution four also failed because I used the following loop:
```for i in range(lastIndex-1, -1, -1):
        ...
```
it failed because "range" will create a space to store a huge number of integers.
Then I try to use "xrange" instead of "range", it succeeds.
xrange will only create a space for one integer.

Solution5 is simplified from Solution four, after reading the article.


56. merge-intervals
"""
Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
"""
Using insert function(Q57) to insert the each interval into another list makes the efficiency quite low.
TODO: improve the efficiency.


57. insert-interval
"""
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].

Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].

This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].
"""

Solution2 is much simplied, however the runtime is larger than that of Solution, a little weird.


69. sqrtx
Implement int sqrt(int x).
Compute and return the square root of x.


88. merge-sorted-array
"""
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.
"""


100. same-tree
"""
Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.
"""


103. binary-tree-zigzag-level-order-traversal
"""
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree {3,9,20,#,#,15,7},

    3
   / \
  9  20
    /  \
   15   7

return its zigzag level order traversal as:

[
    [3],
    [20,9],
    [15,7]
]
"""


104. maximum-depth-of-binary-tree
"""
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
"""


135. candy
"""
There are N children standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum candies you must give?
"""
1. Since the question doesn't define the behavior that whether children should get the same candies if their rating equals with their neighbors, there would be different results for different behaviors.

For example,
the rating of children is:
[1, 1, 1, 2, 2, 3, 4, 10, 10, 10, 9, 8, 7, 6, 5, 4, 3, 3, 2, 1, 1]

then their candies would be:
[1, 1, 1, 2, 2, 3, 4, 10, 10, 10, 9, 8, 7, 6, 5, 4, 3, 3, 2, 1, 1]
or
[1, 1, 1, 2, 1, 2, 3, 4, 1, 8, 7, 6, 5, 4, 3, 2, 1, 3, 2, 1, 1]


2. It doesn't matter to scan the ratings from left to right firstly or from right to left firstly.


136. single-number
Given an array of integers, every element appears twice except for one. Find that single one.

Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 


144. binary-tree-preorder-traversal
"""
Given a binary tree, return the preorder traversal of its nodes' values.

For example:
Given binary tree {1,#,2,3}, return [1, 2, 3]

Note: Recursive solution is trivial, could you do it iteratively?
"""


165. compare-version-numbers
0.1 < 1.1 < 1.2 < 13.37
0.1 = 0.01.0.0


169. majority-element
"""
Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
"""


172. factorial-trailing-zeroes
Given an integer n, return the number of trailing zeroes in n!.
Note: Your solution should be in logarithmic time complexity.


175. combine-two-tables
"""
Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:
"""
use left join


176. second-highest-salary
"""
Write a SQL query to get the second highest salary from the Employee table.
"""


177. nth-highest-salary
"""
Write a SQL query to get the nth highest salary from the Employee table.
"""


178. rank-scores
"""
Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no "holes" between ranks.
"""


179. largest-number
Given a list of non negative integers, arrange them such that they form the largest number.
For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.
Note: the result may be very large, so you need to return a string instead of an integer.


180. consecutive-numbers
"""
Write a SQL query to find all numbers that appear at least three times consecutively.
"""


181. employees-earning-more-than-their-managers
"""
The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.
"""
Using multiple tables select is better than using two tables join.
I.e., first sql is better than second one.


182. duplicate-emails
"""
Write a SQL query to find all duplicate emails in a table named Person.
"""


183. customers-who-never-order
"""
Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.
"""
Using join would be much faster than using "not in (select ...)"


184. department-highest-salary
"""
Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, Max has the highest salary in the IT department and Henry has the highest salary in the Sales department.
"""


185. department-top-three-salaries
"""
Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows.
"""


196. delete-duplicate-emails
"""
Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.
"""


197. rising-temperature
"""
Given a Weather table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.
"""


220. contains-duplicate-iii
"""
Given an array of integers, find out whether there are two distinct indices i and j in the array
such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.
"""
The judge seems to have some problems.


233. number-of-digit-one
"""
Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.

For example:
Given n = 13,
Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.
"""
Suppose the number is ABCDE, considering the following situations:
a. if A = 1, then result += BCDE + 1
b. if A > 1, then result += 9999 + 1 (i.e., 10**4)
c. from B to E, take C as an example:
    if C > 1, then result += AB99 + 1
    if C = 1, then result += ABDE + 1
    if C = 0, then result += (AB-1)DE + 1


235. lowest-common-ancestor-of-a-binary-search-tree
"""
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
For example, a BST is [6, 2, 8, 0, 4, 7, 9, #, #, 3, 5]
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
Then LCA of nodes 2 and 8 is node 6, LCA of nodes 2 and 4 is node 2.
"""


242. valid-anagram
Given two strings s and t, write a function to determine if t is an anagram of s.

For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.

Note:
You may assume the string contains only lowercase alphabets.


262. trips-and-users
round(float_number, 2)


274. h-index
"""
Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."

For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.

Note: If there are several possible values for h, the maximum one is taken as the h-index.
"""


275. h-index-ii
"""
Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?
"""
Solution uses normal search while Solution2 uses binary search.


278. first-bad-version
"""
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.
"""


292. nim-game
"""
You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.

Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.

For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.
"""


316. remove-duplicate-letters
 Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.

 Example:

 Given "bcabc"
 Return "abc"

 Given "cbacdcbc"
 Return "acdb" 


326. power-of-three
Given an integer, write a function to determine if it is a power of three.


338. counting-bits
"""
Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.

Example:
For num = 5 you should return [0,1,1,2,1,2].

Follow up:

It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
Space complexity should be O(n).
Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.
"""
Solution2 is better


345. reverse-vowels-of-a-string
Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:
Given s = "hello", return "holle".

Example 2:
Given s = "leetcode", return "leotcede". 


350. intersection-of-two-arrays-ii
Given two arrays, write a function to compute their intersection.

Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].

Note:

    Each element in the result should appear as many times as it shows in both arrays.
    The result can be in any order.

